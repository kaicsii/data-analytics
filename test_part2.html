<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>生成式AI應用與規劃 - 模擬測驗</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans TC', 'Inter', sans-serif;
        }
        .quiz-option:disabled {
            cursor: not-allowed;
            opacity: 0.9;
        }
        .quiz-option.correct {
            background-color: #22c55e !important; /* bg-green-500 */
            color: white !important;
            border-color: #16a34a !important;
        }
        .quiz-option.incorrect {
            background-color: #ef4444 !important; /* bg-red-500 */
            color: white !important;
            border-color: #dc2626 !important;
        }
        [x-cloak] { display: none; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
</head>
<body class="bg-gray-100 text-gray-800">

    <div x-data="quizApp()" x-init="init" class="max-w-4xl mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900">生成式AI應用與規劃</h1>
            <p class="text-lg text-gray-600 mt-2">模擬測驗</p>
        </header>

        <!-- 開始畫面 -->
        <div x-show="!quizStarted" x-cloak class="bg-white p-8 rounded-2xl shadow-lg text-center">
            <h2 class="text-2xl font-bold mb-4">測驗模式選擇</h2>
            <p class="text-gray-700 mb-6">選擇一個模式開始您的學習之旅。</p>
            <div class="flex flex-col sm:flex-row justify-center gap-4">
                <button @click="startQuiz('normal')" class="bg-blue-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-blue-700 transition-colors duration-300 shadow-md">
                    開始完整測驗
                </button>
                <button @click="startQuiz('review')" :disabled="wronglyAnsweredQuestions.length === 0" class="bg-orange-500 text-white font-bold py-3 px-8 rounded-lg hover:bg-orange-600 transition-colors duration-300 shadow-md disabled:bg-gray-400 disabled:cursor-not-allowed">
                    複習錯題 (<span x-text="wronglyAnsweredQuestions.length"></span>)
                </button>
            </div>
        </div>

        <!-- 測驗進行中 -->
        <div x-show="quizStarted && !quizFinished" x-cloak class="bg-white p-6 md:p-8 rounded-2xl shadow-lg">
            <!-- 進度條和題號 -->
            <div class="mb-6">
                <div class="flex justify-between items-center mb-2">
                    <span class="text-sm font-medium text-gray-600" x-text="`問題 ${currentQuestionIndex + 1} / ${questions.length}`"></span>
                     <span class="text-sm font-bold" :class="isReviewMode ? 'text-orange-600' : 'text-blue-600'" x-text="isReviewMode ? '錯題複習模式' : '完整測驗模式'"></span>
                </div>
                <div class="w-full bg-gray-200 rounded-full h-2.5">
                    <div class="h-2.5 rounded-full" :class="isReviewMode ? 'bg-orange-500' : 'bg-blue-600'" :style="`width: ${((currentQuestionIndex + 1) / questions.length) * 100}%`"></div>
                </div>
            </div>

            <!-- 問題 -->
            <div class="mb-6" x-show="questions.length > 0">
                <p class="text-lg md:text-xl font-semibold mb-2" x-text="questions[currentQuestionIndex].question"></p>
                <span class="text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-blue-600 bg-blue-200" x-text="questions[currentQuestionIndex].category"></span>
            </div>

            <!-- 選項 -->
            <div class="space-y-3" x-show="questions.length > 0">
                <template x-for="(option, index) in questions[currentQuestionIndex].options" :key="index">
                    <button @click="selectAnswer(index)"
                            :disabled="currentAnswerStatus !== null"
                            :class="{
                                'correct': currentAnswerStatus !== null && questions[currentQuestionIndex].options.indexOf(questions[currentQuestionIndex].answer) === index,
                                'incorrect': currentAnswerStatus === 'incorrect' && userAnswers[currentQuestionIndex] === index
                            }"
                            class="w-full text-left p-4 rounded-lg border-2 border-gray-200 hover:bg-gray-50 hover:border-blue-500 transition-all duration-200 quiz-option">
                        <span class="font-medium" x-text="option"></span>
                    </button>
                </template>
            </div>
            
            <!-- 即時解析 -->
            <div x-show="currentAnswerStatus !== null" x-transition class="mt-4 p-4 rounded-lg" :class="currentAnswerStatus === 'correct' ? 'bg-green-100 border-l-4 border-green-500' : 'bg-red-100 border-l-4 border-red-500'">
                 <p class="font-bold" x-text="currentAnswerStatus === 'correct' ? '答對了！' : '答錯了！'"></p>
                 <p class="text-sm" x-text="questions[currentQuestionIndex].explanation"></p>
            </div>


            <!-- 導覽按鈕 -->
            <div class="mt-8 flex justify-end items-center">
                <button x-show="currentAnswerStatus !== null" @click="nextQuestion()"
                        class="bg-blue-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-blue-700 transition-colors">
                    <span x-text="currentQuestionIndex < questions.length - 1 ? '下一題' : '完成測驗'"></span>
                </button>
            </div>
        </div>

        <!-- 結果畫面 -->
        <div x-show="quizFinished" x-cloak class="bg-white p-8 rounded-2xl shadow-lg">
            <h2 class="text-2xl md:text-3xl font-bold text-center mb-4">測驗結束！</h2>
            <p class="text-center text-xl mb-6" x-text="`您的總分是： ${score} / ${questions.length}`"></p>
            
            <div class="text-center mb-8 flex flex-col sm:flex-row justify-center items-center gap-4">
                <button @click="restartQuiz()" class="bg-blue-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-blue-700 transition-colors duration-300 shadow-md">
                    返回主畫面
                </button>
            </div>
            
            <!-- 答案回顧 -->
            <h3 class="text-xl font-bold mb-4 border-t pt-6">本次測驗回顧</h3>
            <div class="space-y-6">
                <template x-for="(question, index) in questions" :key="index">
                    <div class="border p-4 rounded-lg" :class="question.correctlyAnswered ? 'bg-green-50' : 'bg-red-50'">
                        <p class="font-semibold mb-2" x-text="`${index + 1}. ${question.question}`"></p>
                        <div class="space-y-2">
                            <template x-for="(option, optionIndex) in question.options" :key="optionIndex">
                                <div class="p-3 rounded-md text-sm"
                                     :class="{
                                         'correct': option === question.answer,
                                         'incorrect': userAnswers[index] === optionIndex && option !== question.answer,
                                         'bg-gray-100': userAnswers[index] !== optionIndex && option !== question.answer
                                     }">
                                    <span x-text="option"></span>
                                    <span x-if="option === question.answer"> (正確答案)</span>
                                    <span x-if="userAnswers[index] === optionIndex && option !== question.answer"> (您的答案)</span>
                                </div>
                            </template>
                        </div>
                        <div class="mt-3 p-3 bg-blue-100 border-l-4 border-blue-500 text-blue-800 rounded-r-lg">
                            <p class="font-bold">解析：</p>
                            <p x-text="question.explanation"></p>
                        </div>
                    </div>
                </template>
            </div>
        </div>
    </div>

    <script>
        function quizApp() {
            return {
                quizStarted: false,
                quizFinished: false,
                isReviewMode: false,
                currentQuestionIndex: 0,
                score: 0,
                currentAnswerStatus: null, // null, 'correct', 'incorrect'
                userAnswers: [],
                questions: [],
                wronglyAnsweredQuestions: [],
                
                fullQuestionBank: [
                    // --- No code/Low code 概念 ---
                    { id: 101, question: "關於 No Code 與 Low Code 平台的敘述，下列何者最為正確？", options: ["A) No Code 平台適合專業開發者進行複雜的系統整合", "B) Low Code 平台完全不需要撰寫任何程式碼", "C) No Code 平台讓非技術背景者能透過視覺化介面開發應用", "D) 兩者功能完全相同，只是名稱不同"], answer: "C) No Code 平台讓非技術背景者能透過視覺化介面開發應用", explanation: "No Code 平台的核心價值在於透過拖放和視覺化設定，讓沒有程式設計背景的使用者也能建立應用程式，大幅降低技術門檻。", category: "No code/Low code 概念" },
                    { id: 102, question: "生成式AI與 No Code/Low Code 平台結合，可以帶來什麼好處？", options: ["A) 只能用於自動生成行銷文案", "B) 會增加開發的複雜度與時間", "C) 可以自動生成程式碼、優化UI/UX設計，並提供數據分析建議", "D) 會完全取代人類設計師與開發者的工作"], answer: "C) 可以自動生成程式碼、優化UI/UX設計，並提供數據分析建議", explanation: "生成式AI能賦予 No Code/Low Code 平台更強大的能力，例如根據描述自動生成程式碼片段、提供介面設計建議、分析數據等，從而進一步提升開發效率。", category: "No code/Low code 概念" },
                    { id: 103, question: "企業在選擇 No Code/Low Code 平台時，下列哪個不是重要的評估因素？", options: ["A) 平台的安全性與法規合規性", "B) 平台與現有系統的整合能力", "C) 平台開發商的股票價格", "D) 技術支援與社群資源的活躍度"], answer: "C) 平台開發商的股票價格", explanation: "評估平台應著重於其功能、安全性、擴展性、成本效益及技術支援，開發商的股價與平台本身的適用性沒有直接關聯。", category: "No code/Low code 概念" },
                    { id: 104, question: "「市民開發者 (Citizen Developer)」通常是指哪一類人？", options: ["A) 專業的軟體工程師", "B) 利用 No Code/Low Code 工具解決業務問題的非技術背景員工", "C) 負責資訊安全的管理人員", "D) 大學資訊科系的學生"], answer: "B) 利用 No Code/Low Code 工具解決業務問題的非技術背景員工", explanation: "市民開發者是指那些身處業務第一線，利用被認可的開發工具（主要是No Code/Low Code平台）來創建自己所需應用的員工，他們通常不具備專業的程式開發背景。", category: "No code/Low code 概念" },
                    { id: 105, question: "將生成式AI與 No Code/Low Code 平台結合時，可能面臨的主要挑戰不包含下列何者？", options: ["A) 模型生成內容的準確性與可靠性", "B) 訓練數據可能引發的資料隱私與安全問題", "C) 平台功能過於簡單，無法擴展", "D) AI模型可能帶有的偏見與倫理風險"], answer: "C) 平台功能過於簡單，無法擴展", explanation: "結合AI後的挑戰主要在於AI模型本身，如準確性、隱私、偏見等。而 No Code/Low Code 平台本身通常具備一定的擴展性，這不是結合後產生的主要挑戰。", category: "No code/Low code 概念" },
                    // --- 生成式AI應用領域與工具使用 ---
                    { id: 106, question: "在生成式AI的技術架構中，「溫度參數 (Temperature Parameter)」主要用來控制什麼？", options: ["A) 模型訓練的速度", "B) 生成內容的隨機性與創造力", "C) 模型消耗的計算資源", "D) 生成內容的字數長度"], answer: "B) 生成內容的隨機性與創造力", explanation: "溫度參數用來調整模型輸出的機率分佈。較低的溫度會使模型傾向選擇機率最高的詞，生成結果較保守、一致；較高的溫度則會增加低機率詞被選中的機會，生成結果更具隨機性與創意。", category: "生成式AI應用領域與工具使用" },
                    { id: 107, question: "下列何者是生成式AI在醫療保健領域的典型應用？", options: ["A) 自動化工廠的生產排程", "B) 預測股票市場的漲跌", "C) 分析生物醫學數據以加速藥物發現", "D) 設計建築物的藍圖"], answer: "C) 分析生物醫學數據以加速藥物發現", explanation: "生成式AI可以分析大量生物醫學文獻和分子結構數據，生成新的、有潛力的藥物分子結構，從而大幅縮短藥物研發的週期。", category: "生成式AI應用領域與工具使用" },
                    { id: 108, question: "提示工程師 (Prompt Engineer) 的主要工作職責是什麼？", options: ["A) 維護伺服器硬體", "B) 設計和優化對大型語言模型的指令，以獲得更好的輸出結果", "C) 撰寫傳統的應用程式後端程式碼", "D) 進行市場銷售與客戶關係管理"], answer: "B) 設計和優化對大型語言模型的指令，以獲得更好的輸出結果", explanation: "隨著大型生成式AI的興起，如何有效地與AI溝通成為一項新興專業。提示工程師專門研究如何設計提示（Prompt），以引導AI產生最符合需求的內容。", category: "生成式AI應用領域與工具使用" },
                    { id: 109, question: "在生成式AI工具中，RLHF (Reinforcement Learning from Human Feedback) 技術的主要目的是什麼？", options: ["A) 提高模型的計算速度", "B) 增加模型生成的內容長度", "C) 讓模型的生成結果更符合人類的偏好與期望", "D) 降低模型訓練所需的數據量"], answer: "C) 讓模型的生成結果更符合人類的偏好與期望", explanation: "人類回饋強化學習（RLHF）是透過收集人類對模型輸出結果的偏好排序，來微調模型，使其生成的內容更安全、更有用，且更符合人類的價值觀。", category: "生成式AI應用領域與工具使用" },
                    { id: 110, question: "「AI幻覺 (AI hallucinations)」是指生成式AI的哪一種現象？", options: ["A) AI產生了極具創意的藝術作品", "B) AI生成了完全準確且基於事實的資訊", "C) AI自信地產生了看似合理但實際上是錯誤或虛構的資訊", "D) AI拒絕回答使用者的問題"], answer: "C) AI自信地產生了看似合理但實際上是錯誤或虛構的資訊", explanation: "AI幻覺是大型語言模型的一個已知問題，指的是模型可能會「編造」出一些不存在的事實、數據或引用，並且以非常確信的語氣呈現出來。", category: "生成式AI應用領域與工具使用" },
                    { id: 111, question: "下列哪一個平台提供了大量的開源AI模型與資料集，極大地推動了AI社群的合作與發展？", options: ["A) Microsoft Office", "B) Adobe Photoshop", "C) Hugging Face", "D) Netflix"], answer: "C) Hugging Face", explanation: "Hugging Face是一個著名的AI社群與平台，提供了大量的預訓練模型、資料集和開發工具，成為開發者與研究人員共享與協作的重要資源庫。", category: "生成式AI應用領域與工具使用" },
                    { id: 112, question: "生成式AI在教育領域的應用，不包括下列哪一項？", options: ["A) 為學生設計個人化的學習路徑", "B) 自動生成教學材料與練習題", "C) 完全取代教師的教學與引導角色", "D) 作為智慧教學助理，即時回答學生的問題"], answer: "C) 完全取代教師的教學與引導角色", explanation: "生成式AI在教育領域應被視為強大的輔助工具，它可以分擔重複性工作並提供個人化支持，但無法取代教師在情感交流、價值觀引導和複雜情境判斷中的關鍵角色。", category: "生成式AI應用領域與工具使用" },
                    { id: 113, question: "在評估生成式AI模型的語言生成品質時，BLEU和ROUGE是常用的什麼？", options: ["A) 硬體效能指標", "B) 量化評估指標", "C) 模型訓練時間單位", "D) 使用者滿意度問卷"], answer: "B) 量化評估指標", explanation: "BLEU和ROUGE是兩種常用的自動評估指標，透過比較模型生成的文本與人類參考翻譯或摘要的重疊程度，來量化評估翻譯或摘要任務的品質。", category: "生成式AI應用領域與工具使用" },
                    // --- 生成式AI導入評估規劃 ---
                    { id: 114, question: "企業在導入生成式AI之前，進行「痛點識別」的主要目的是什麼？", options: ["A) 了解競爭對手的AI技術", "B) 挖掘現有營運流程中的瓶頸與挑戰，以確定AI的應用目標", "C) 評估公司股票的市場價值", "D) 招聘更多的AI技術人才"], answer: "B) 挖掘現有營運流程中的瓶頸與挑戰，以確定AI的應用目標", explanation: "導入AI應以解決實際問題為導向。痛點識別幫助企業找出最需要改進的環節，從而確保AI的投入能夠帶來最大的業務價值。", category: "生成式AI導入評估規劃" },
                    { id: 115, question: "在生成式AI導入的「準備階段」，企業應優先選擇哪一類專案開始？", options: ["A) 技術最複雜、最具挑戰性的專案", "B) 投資金額最高的專案", "C) 能夠影響所有部門的超大型專案", "D) 從簡單且可行的核心專案開始，進行小規模試點"], answer: "D) 從簡單且可行的核心專案開始，進行小規模試點", explanation: "採用分階段策略，從風險可控的小規模試點專案（POC）開始，有助於驗證技術可行性、累積經驗並建立內部信心，為後續的大規模推廣奠定基礎。", category: "生成式AI導入評估規劃" },
                    { id: 116, question: "企業評估導入生成式AI的投資回報率（ROI）時，應考慮哪些效益？", options: ["A) 僅考慮節省的人力成本", "B) 僅考慮增加的軟體授權費用", "C) 應綜合評估直接效益（如營收增長）與間接效益（如流程效率提升）", "D) 僅考慮硬體設備的折舊"], answer: "C) 應綜合評估直接效益（如營收增長）與間接效益（如流程效率提升）", explanation: "一個全面的ROI分析需要考慮AI導入所帶來的多方面價值，包括可量化的財務回報（如營收、成本）和較難量化的營運效益（如效率、客戶滿意度）。", category: "生成式AI導入評估規劃" },
                    { id: 117, question: "在生成式AI的風險管理中，「差分隱私（Differential Privacy）」技術主要用於應對哪一類風險？", options: ["A) 模型產生偏見的風險", "B) 訓練數據中的敏感資訊洩漏風險", "C) AI生成內容侵犯版權的風險", "D) 模型計算成本過高的風險"], answer: "B) 訓練數據中的敏感資訊洩漏風險", explanation: "差分隱私是一種在數據集中添加數學上可證明的噪音的技術，使得在進行數據分析時，無法輕易反推出單一個體的具體資訊，從而保護個人隱私。", category: "生成式AI導入評估規劃" },
                    { id: 118, question: "當一個生成式AI模型在訓練時，其訓練數據反映了社會上對特定職業的性別刻板印象，這可能導致什麼風險？", options: ["A) 數據漂移 (Data Drift)", "B) 倫理偏見與歧視", "C) 反向工程攻擊", "D) 提示詞攻擊"], answer: "B) 倫理偏見與歧視", explanation: "如果訓練數據本身存在偏見，AI模型會學習並放大這些偏見，導致其生成的內容帶有歧視性，這是一個嚴重的倫理風險。", category: "生成式AI導入評估規劃" },
                    { id: 119, question: "企業導入生成式AI後，為了確保模型長期有效，應建立「模型監控與重新訓練」機制，其主要目的不包括下列何者？", options: ["A) 追蹤模型表現，及早發現效能下降", "B) 檢查輸入數據的分佈變化（數據漂移）", "C) 在模型效能下降時，自動觸發重新訓練", "D) 永久使用最初訓練好的模型，不再更動"], answer: "D) 永久使用最初訓練好的模型，不再更動", explanation: "真實世界的數據是動態變化的，因此模型需要持續監控和更新（重新訓練），以適應新的數據分佈和業務需求，從而保持其準確性和有效性。", category: "生成式AI導入評估規劃" },
                    { id: 120, question: "在風險管理的策略中，企業透過購買保險來應對AI可能造成的潛在損失，這屬於哪一種風險應對策略？", options: ["A) 風險規避", "B) 風險緩解", "C) 風險轉移", "D) 風險接受"], answer: "C) 風險轉移", explanation: "風險轉移是將風險的財務後果轉移給第三方（如保險公司）的策略，企業支付保費，以換取在風險事件發生時獲得賠償。", category: "生成式AI導入評估規劃" },
                    { id: 121, question: "在生成式AI導入的「驗證POC」階段，A/B測試的主要用途是什麼？", options: ["A) 確保所有員工都完成了培訓", "B) 比較不同版本模型的效能，選擇表現更佳的版本", "C) 計算專案的總開發成本", "D) 檢查訓練數據是否存在偏見"], answer: "B) 比較不同版本模型的效能，選擇表現更佳的版本", explanation: "A/B測試是一種實驗方法，透過將使用者隨機分組，分別體驗不同版本的模型或功能，並根據數據指標（如點擊率、轉換率）來客觀地評估哪個版本表現更好。", category: "生成式AI導入評估規劃" },
                    { id: 122, question: "下列何者是生成式AI在法律領域應用時，最主要的挑戰？", options: ["A) 生成的法律文件格式不美觀", "B) 確保生成內容的準確性、合規性及處理機密資訊的安全性", "C) AI無法理解複雜的法律術語", "D) 律師不願意使用新科技"], answer: "B) 確保生成內容的準確性、合規性及處理機密資訊的安全性", explanation: "法律領域對精確性和保密性有極高的要求。AI生成的內容必須絕對準確且符合現行法規，同時客戶的機密資訊也必須受到最高等級的保護，這是其應用時最大的挑戰。", category: "生成式AI導入評估規劃" },
                    { id: 123, question: "企業導入AI時，為何需要評估「技術對接性」？", options: ["A) 為了確保新AI系統能與企業現有的IT基礎設施和軟體（如CRM、ERP）順利整合", "B) 為了了解最新的AI硬體趨勢", "C) 為了計算員工的平均技術水平", "D) 為了撰寫公司年度報告"], answer: "A) 為了確保新AI系統能與企業現有的IT基礎設施和軟體（如CRM、ERP）順利整合", explanation: "評估技術對接性是為了避免新舊系統之間出現數據孤島或流程中斷的問題，確保AI工具能夠無縫地融入現有工作流程，發揮最大效益。", category: "生成式AI導入評估規劃" },
                    { id: 124, question: "在風險評估中，使用「風險矩陣 (Risk Matrix)」主要是為了什麼？", options: ["A) 創造新的AI模型", "B) 將風險的「發生概率」與「影響程度」進行交叉分析，以確定風險的優先級", "C) 將所有風險責任轉移給第三方", "D) 訓練員工如何應對所有風險"], answer: "B) 將風險的「發生概率」與「影響程度」進行交叉分析，以確定風險的優先級", explanation: "風險矩陣是一個視覺化工具，它幫助決策者直觀地比較不同風險的嚴重性，從而將有限的資源集中用於處理最高優先級的風險。", category: "生成式AI導入評估規劃" },
                    { id: 125, question: "「可解釋性AI (Explainable AI, XAI)」技術的發展，主要是為了解決生成式AI的哪個問題？", options: ["A) 計算速度太慢", "B) 模型決策過程像「黑箱」一樣不透明，難以理解與信任", "C) 訓練數據不足", "D) 生成的圖像解析度不夠高"], answer: "B) 模型決策過程像「黑箱」一樣不透明，難以理解與信任", explanation: "許多複雜的AI模型（特別是深度學習模型）的內部決策邏輯非常複雜，難以解釋。XAI的目標就是開發技術來解釋AI是如何做出特定決策的，以增加模型的透明度、可信度和可靠性。", category: "生成式AI導入評估規劃" }
                ],

                init() {
                    this.loadWrongAnswers();
                },

                loadWrongAnswers() {
                    const saved = localStorage.getItem('gen_ai_wronglyAnsweredQuestions');
                    if (saved) {
                        this.wronglyAnsweredQuestions = JSON.parse(saved);
                    }
                },

                saveWrongAnswers() {
                    localStorage.setItem('gen_ai_wronglyAnsweredQuestions', JSON.stringify(this.wronglyAnsweredQuestions));
                },

                shuffleArray(array) {
                    let newArr = [...array];
                    for (let i = newArr.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [newArr[i], newArr[j]] = [newArr[j], newArr[i]];
                    }
                    return newArr;
                },

                startQuiz(mode) {
                    this.isReviewMode = mode === 'review';
                    if (this.isReviewMode) {
                        this.questions = this.shuffleArray(this.wronglyAnsweredQuestions);
                    } else {
                        this.questions = this.shuffleArray(this.fullQuestionBank).slice(0, 25);
                    }
                    this.userAnswers = Array(this.questions.length).fill(null);
                    this.questions.forEach(q => q.correctlyAnswered = null);
                    this.currentQuestionIndex = 0;
                    this.score = 0;
                    this.currentAnswerStatus = null;
                    this.quizFinished = false;
                    this.quizStarted = true;
                },

                selectAnswer(selectedIndex) {
                    if (this.currentAnswerStatus !== null) return;

                    const currentQuestion = this.questions[this.currentQuestionIndex];
                    const correctIndex = currentQuestion.options.indexOf(currentQuestion.answer);
                    
                    this.userAnswers[this.currentQuestionIndex] = selectedIndex;

                    if (selectedIndex === correctIndex) {
                        this.currentAnswerStatus = 'correct';
                        currentQuestion.correctlyAnswered = true;
                        this.score++;
                        if (this.isReviewMode) {
                           this.wronglyAnsweredQuestions = this.wronglyAnsweredQuestions.filter(q => q.id !== currentQuestion.id);
                           this.saveWrongAnswers();
                        }
                    } else {
                        this.currentAnswerStatus = 'incorrect';
                        currentQuestion.correctlyAnswered = false;
                        if (!this.isReviewMode) {
                            const isAlreadyWrong = this.wronglyAnsweredQuestions.some(q => q.id === currentQuestion.id);
                            if (!isAlreadyWrong) {
                                this.wronglyAnsweredQuestions.push(currentQuestion);
                                this.saveWrongAnswers();
                            }
                        }
                    }
                },

                nextQuestion() {
                    if (this.currentQuestionIndex < this.questions.length - 1) {
                        this.currentQuestionIndex++;
                        this.currentAnswerStatus = null;
                    } else {
                        this.finishQuiz();
                    }
                },

                finishQuiz() {
                    this.quizFinished = true;
                },

                restartQuiz() {
                    this.quizStarted = false;
                    this.quizFinished = false;
                }
            }
        }
        document.addEventListener('alpine:init', () => {
            Alpine.data('quizApp', quizApp);
        });
    </script>
</body>
</html>
