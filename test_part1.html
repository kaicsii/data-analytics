<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>人工智慧基礎概論 - 模擬測驗 (Gemini版)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans TC', 'Inter', sans-serif;
        }
        .quiz-option:disabled {
            cursor: not-allowed;
            opacity: 0.9;
        }
        .quiz-option.correct {
            background-color: #22c55e !important; /* bg-green-500 */
            color: white !important;
            border-color: #16a34a !important;
        }
        .quiz-option.incorrect {
            background-color: #ef4444 !important; /* bg-red-500 */
            color: white !important;
            border-color: #dc2626 !important;
        }
        [x-cloak] { display: none; }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #09f;
            animation: spin 1s ease infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .prose {
            max-width: 65ch;
            color: #374151;
        }
        .prose strong {
            color: #111827;
            font-weight: 600;
        }
        .prose pre {
            background-color: #f3f4f6;
            padding: 1em;
            border-radius: 0.5rem;
            overflow-x: auto;
        }
        .prose code {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
</head>
<body class="bg-gray-100 text-gray-800">

    <div x-data="quizApp" x-init="init" class="max-w-4xl mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900">人工智慧基礎概論</h1>
            <p class="text-lg text-gray-600 mt-2">模擬測驗 (Gemini 智慧增強版)</p>
        </header>

        <!-- 開始畫面 -->
        <div x-show="!quizStarted" x-cloak class="bg-white p-8 rounded-2xl shadow-lg text-center">
            <h2 class="text-2xl font-bold mb-4">測驗模式選擇</h2>
            <p class="text-gray-700 mb-6">選擇一個模式開始您的學習之旅。</p>
            <div class="flex flex-col sm:flex-row justify-center gap-4">
                <button @click="startQuiz('normal')" class="bg-blue-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-blue-700 transition-colors duration-300 shadow-md">
                    開始完整測驗
                </button>
                <button @click="startQuiz('review')" :disabled="wronglyAnsweredQuestions.length === 0" class="bg-orange-500 text-white font-bold py-3 px-8 rounded-lg hover:bg-orange-600 transition-colors duration-300 shadow-md disabled:bg-gray-400 disabled:cursor-not-allowed">
                    複習錯題 (<span x-text="wronglyAnsweredQuestions.length"></span>)
                </button>
            </div>
        </div>

        <!-- 測驗進行中 -->
        <div x-show="quizStarted && !quizFinished" x-cloak class="bg-white p-6 md:p-8 rounded-2xl shadow-lg">
            <!-- 進度條和題號 -->
            <div class="mb-6">
                <div class="flex justify-between items-center mb-2">
                    <span class="text-sm font-medium text-gray-600" x-text="`問題 ${currentQuestionIndex + 1} / ${questions.length}`"></span>
                     <span class="text-sm font-bold" :class="isReviewMode ? 'text-orange-600' : 'text-blue-600'" x-text="isReviewMode ? '錯題複習模式' : '完整測驗模式'"></span>
                </div>
                <div class="w-full bg-gray-200 rounded-full h-2.5">
                    <div class="h-2.5 rounded-full" :class="isReviewMode ? 'bg-orange-500' : 'bg-blue-600'" :style="`width: ${((currentQuestionIndex + 1) / questions.length) * 100}%`"></div>
                </div>
            </div>

            <!-- 問題 -->
            <div class="mb-6" x-show="questions.length > 0">
                <p class="text-lg md:text-xl font-semibold mb-2" x-text="questions[currentQuestionIndex].question"></p>
                <span class="text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-blue-600 bg-blue-200" x-text="questions[currentQuestionIndex].category"></span>
            </div>

            <!-- 選項 -->
            <div class="space-y-3" x-show="questions.length > 0">
                <template x-for="(option, index) in questions[currentQuestionIndex].options" :key="index">
                    <button @click="selectAnswer(index)"
                            :disabled="currentAnswerStatus !== null"
                            :class="{
                                'correct': currentAnswerStatus !== null && questions[currentQuestionIndex].options.indexOf(questions[currentQuestionIndex].answer) === index,
                                'incorrect': currentAnswerStatus === 'incorrect' && userAnswers[currentQuestionIndex] === index
                            }"
                            class="w-full text-left p-4 rounded-lg border-2 border-gray-200 hover:bg-gray-50 hover:border-blue-500 transition-all duration-200 quiz-option">
                        <span class="font-medium" x-text="option"></span>
                    </button>
                </template>
            </div>
            
            <!-- 即時解析 -->
            <div x-show="currentAnswerStatus !== null" x-transition class="mt-4 p-4 rounded-lg" :class="currentAnswerStatus === 'correct' ? 'bg-green-100 border-l-4 border-green-500' : 'bg-red-100 border-l-4 border-red-500'">
                 <p class="font-bold" x-text="currentAnswerStatus === 'correct' ? '答對了！' : '答錯了！'"></p>
                 <p class="text-sm" x-text="questions[currentQuestionIndex].explanation"></p>
            </div>


            <!-- 導覽按鈕 -->
            <div class="mt-8 flex justify-end items-center">
                <button x-show="currentAnswerStatus !== null" @click="nextQuestion()"
                        class="bg-blue-600 text-white font-bold py-2 px-6 rounded-lg hover:bg-blue-700 transition-colors">
                    <span x-text="currentQuestionIndex < questions.length - 1 ? '下一題' : '完成測驗'"></span>
                </button>
            </div>
        </div>

        <!-- 結果畫面 -->
        <div x-show="quizFinished" x-cloak class="bg-white p-8 rounded-2xl shadow-lg">
            <h2 class="text-2xl md:text-3xl font-bold text-center mb-4">測驗結束！</h2>
            <p class="text-center text-xl mb-6" x-text="`您的總分是： ${score} / ${questions.length}`"></p>
            
            <div class="text-center mb-8 flex flex-col sm:flex-row justify-center items-center gap-4">
                <button @click="restartQuiz()" class="bg-blue-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-blue-700 transition-colors duration-300 shadow-md">
                    返回主畫面
                </button>
                <button @click="summarizeWeaknesses()" class="bg-purple-600 text-white font-bold py-3 px-8 rounded-lg hover:bg-purple-700 transition-colors duration-300 shadow-md" :disabled="score === questions.length">
                    總結我的弱點 ✨
                </button>
            </div>
            
            <!-- 答案回顧 -->
            <h3 class="text-xl font-bold mb-4 border-t pt-6">本次測驗回顧</h3>
            <div class="space-y-6">
                <template x-for="(question, index) in questions" :key="index">
                    <div class="border p-4 rounded-lg" :class="question.correctlyAnswered ? 'bg-green-50' : 'bg-red-50'">
                        <p class="font-semibold mb-2" x-text="`${index + 1}. ${question.question}`"></p>
                        <div class="space-y-2">
                            <template x-for="(option, optionIndex) in question.options" :key="optionIndex">
                                <div class="p-3 rounded-md text-sm"
                                     :class="{
                                         'correct': option === question.answer,
                                         'incorrect': userAnswers[index] === optionIndex && option !== question.answer,
                                         'bg-gray-100': userAnswers[index] !== optionIndex && option !== question.answer
                                     }">
                                    <span x-text="option"></span>
                                    <span x-if="option === question.answer"> (正確答案)</span>
                                    <span x-if="userAnswers[index] === optionIndex && option !== question.answer"> (您的答案)</span>
                                </div>
                            </template>
                        </div>
                        <div class="mt-3 p-3 bg-blue-100 border-l-4 border-blue-500 text-blue-800 rounded-r-lg">
                            <p class="font-bold">解析：</p>
                            <p x-text="question.explanation"></p>
                        </div>
                        <!-- Gemini 功能按鈕 -->
                        <div class="mt-4 flex flex-wrap gap-2">
                            <button @click="getDeeperExplanation(index)" class="text-sm bg-indigo-100 text-indigo-700 py-1 px-3 rounded-full hover:bg-indigo-200 transition">深入解釋 ✨</button>
                            <button @click="generateSimilarQuestion(index)" class="text-sm bg-teal-100 text-teal-700 py-1 px-3 rounded-full hover:bg-teal-200 transition">產生類似題目 ✨</button>
                        </div>
                    </div>
                </template>
            </div>
        </div>

        <!-- Gemini Modal -->
        <div x-show="showGeminiModal" @click.away="showGeminiModal = false" x-cloak class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
            <div class="bg-white rounded-lg shadow-xl max-w-2xl w-full max-h-[90vh] overflow-y-auto p-6" @click.stop>
                <h3 class="text-xl font-bold mb-4" x-text="geminiModalTitle"></h3>
                <div x-show="isGeminiLoading" class="flex justify-center items-center h-48">
                    <div class="spinner"></div>
                </div>
                <div x-show="!isGeminiLoading" class="prose max-w-none" x-html="geminiResponse"></div>
                <div class="mt-6 text-right">
                    <button @click="showGeminiModal = false" class="bg-gray-500 text-white font-bold py-2 px-6 rounded-lg hover:bg-gray-600 transition-colors">關閉</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        function quizApp() {
            return {
                quizStarted: false,
                quizFinished: false,
                isReviewMode: false,
                currentQuestionIndex: 0,
                score: 0,
                currentAnswerStatus: null, // null, 'correct', 'incorrect'
                userAnswers: [],
                questions: [],
                wronglyAnsweredQuestions: [],
                showGeminiModal: false,
                isGeminiLoading: false,
                geminiResponse: '',
                geminiModalTitle: '',
                
                fullQuestionBank: [
                    // --- 人工智慧概念 ---
                    { id: 1, question: "下列何者最能描述人工智慧（AI）的定義？", options: ["A) 一種只能執行單一重複性任務的程式", "B) 一種旨在模擬人類智慧，使機器能學習、推理與解決問題的技術", "C) 僅限於製造業使用的自動化機器人技術", "D) 一種用於儲存大量資料的資料庫系統"], answer: "B) 一種旨在模擬人類智慧，使機器能學習、推理與解決問題的技術", explanation: "人工智慧（AI）是一個廣泛的領域，旨在讓機器模擬人類的智慧行為，包括學習、推理、感知和解決問題等能力。", category: "人工智慧概念" },
                    { id: 2, question: "根據功能不同，可以根據使用者輸入的提示詞（prompt）生成文字、語音、圖像和影片的AI屬於哪一種類型？", options: ["A) 分析型AI", "B) 預測型AI", "C) 生成型AI", "D) 專家型AI"], answer: "C) 生成型AI", explanation: "生成型AI（Generative AI）近年來快速發展，其主要功能是根據使用者輸入的提示詞來創造新的內容，如文字、圖片等。", category: "人工智慧概念" },
                    { id: 3, question: "在人工智慧的應用領域中，利用AI分析醫學影像（如X光片、MRI）以輔助醫師進行精準診斷，是屬於哪個領域的應用？", options: ["A) 金融", "B) 製造業", "C) 交通", "D) 醫療保健"], answer: "D) 醫療保健", explanation: "將AI技術應用於分析醫學影像，以輔助疾病診斷，是AI在醫療保健領域中的一個重要且常見的應用實例。", category: "人工智慧概念" },
                    { id: 4, question: "在人工智慧的架構中，提供必要的計算能力、數據支撐與核心演算法的部分被稱為什麼？", options: ["A) 開發應用層", "B) 實際運用層", "C) 技術底層", "D) 使用者介面層"], answer: "C) 技術底層", explanation: "技術底層是AI運作的基礎，包含了資料處理、演算法、機器學習、深度學習等核心要素，為上層應用提供支持。", category: "人工智慧概念" },
                    { id: 5, question: "TensorFlow 和 PyTorch 是深度學習領域中常見的什麼？", options: ["A) 硬體晶片", "B) 作業系統", "C) 開發框架", "D) 程式語言"], answer: "C) 開發框架", explanation: "TensorFlow 和 PyTorch 是兩個主流的開源深度學習框架，提供了豐富的工具和函式庫，簡化了深度學習模型的開發過程。", category: "人工智慧概念" },
                    // --- 資料處理與分析概念 ---
                    { id: 6, question: "在資料結構類型中，XML、JSON、CSV 格式的資料通常被歸類為？", options: ["A) 結構化數據", "B) 半結構化數據", "C) 非結構化數據", "D) 序列化數據"], answer: "B) 半結構化數據", explanation: "半結構化數據具有一定的結構標籤（如XML的標籤、JSON的鍵值對），但格式相對靈活，不像關聯式資料庫那樣有嚴格的固定架構。", category: "資料處理與分析概念" },
                    { id: 7, question: "在資料清洗過程中，處理數據中某些欄位沒有記錄有效數據的情況，稱為什麼？", options: ["A) 處理重複值", "B) 處理錯誤值", "C) 處理離群值", "D) 處理遺缺值"], answer: "D) 處理遺缺值", explanation: "遺缺值（Missing Value）是指數據集中某些欄位缺少數值的問題。處理方法包括填補（如使用平均值）或刪除該筆記錄。", category: "資料處理與分析概念" },
                    { id: 8, question: "將數值數據縮放到特定範圍（如[0,1]），以消除不同變數之間的單位影響，這個過程稱為什麼？", options: ["A) 數據離散化", "B) 數據縮減", "C) 數據正規化/標準化", "D) 數據格式轉換"], answer: "C) 數據正規化/標準化", explanation: "數據正規化/標準化是為了消除特徵間的量綱差異，讓不同尺度的特徵在模型中有可比性，是數據預處理的重要步驟。", category: "資料處理與分析概念" },
                    { id: 9, question: "哪一種數據分析方法旨在描述數據的基本特徵和分佈情況，例如計算平均值、中位數、標準差等？", options: ["A) 敘述性分析", "B) 探索性分析", "C) 診斷性分析", "D) 預測性分析"], answer: "A) 敘述性分析", explanation: "敘述性分析（Descriptive Analysis）是數據分析的基礎，主要使用統計指標和圖表來總結和呈現數據的現狀與基本特徵。", category: "資料處理與分析概念" },
                    { id: 10, question: "在統計指標中，哪一個量數較不受極端值（離群值）的影響？", options: ["A) 平均值 (Mean)", "B) 中位數 (Median)", "C) 全距 (Range)", "D) 標準差 (Standard Deviation)"], answer: "B) 中位數 (Median)", explanation: "中位數是將數據排序後位於中間位置的值，因此它不像平均值那樣會被極端的最大或最小值拉動，能更好地反映數據的中心趨勢。", category: "資料處理與分析概念" },
                    { id: 11, question: "主成分分析（Principal Component Analysis, PCA）是一種常用於什麼目的的技術？", options: ["A) 數據分類", "B) 數據聚類", "C) 數據降維", "D) 數據預測"], answer: "C) 數據降維", explanation: "PCA 是一種常見的數據縮減（降維）技術，它透過線性變換將高維數據轉換為低維特徵，同時保留大部分原始數據的訊息。", category: "資料處理與分析概念" },
                    { id: 12, question: "下列哪一種搜尋演算法在搜尋前需要資料集預先排序？", options: ["A) 線性搜尋 (Linear Search)", "B) 二分搜尋 (Binary Search)", "C) 深度優先搜尋 (DFS)", "D) 廣度優先搜尋 (BFS)"], answer: "B) 二分搜尋 (Binary Search)", explanation: "二分搜尋的運作原理是反覆將搜尋範圍切成兩半，這要求資料集必須是已排序的，才能正確地判斷目標值在哪一半區域。", category: "資料處理與分析概念" },
                    // --- 機器學習概念 ---
                    { id: 13, question: "在機器學習中，使用帶有標記（Labeled Data）的訓練數據來訓練模型，使其學習輸入與輸出之間關聯性的方法稱為什麼？", options: ["A) 監督式學習", "B) 非監督式學習", "C) 強化學習", "D) 半監督式學習"], answer: "A) 監督式學習", explanation: "監督式學習的核心特徵就是使用有標記的數據進行訓練，模型在「監督」下學習如何從輸入預測正確的輸出標籤。", category: "機器學習概念" },
                    { id: 14, question: "垃圾郵件過濾、影像識別（辨識圖片中的物件類別）等任務，在監督式學習中屬於哪一種類型的問題？", options: ["A) 迴歸 (Regression)", "B) 分類 (Classification)", "C) 聚類 (Clustering)", "D) 降維 (Dimensionality Reduction)"], answer: "B) 分類 (Classification)", explanation: "分類任務的目標是將輸入數據分配到預先定義好的類別中，例如「垃圾郵件」或「非垃圾郵件」，或者圖片中的「貓」、「狗」等。", category: "機器學習概念" },
                    { id: 15, question: "哪一種學習方法是讓代理（Agent）透過與環境互動，並根據回饋（獎勵或懲罰）來學習最佳行動策略？", options: ["A) 監督式學習", "B) 非監督式學習", "C) 強化學習", "D) 遷移學習"], answer: "C) 強化學習", explanation: "強化學習（Reinforcement Learning）的核心是「試錯學習」，代理在環境中行動，並從結果中學習如何做出能獲得最大累積獎勵的決策。", category: "機器學習概念" },
                    { id: 16, question: "在深度學習中，哪一種神經網路模型特別擅長處理圖像數據，並能高效地提取如邊緣、紋理等局部特徵？", options: ["A) 循環神經網路 (RNN)", "B) 卷積神經網路 (CNN)", "C) 生成對抗網路 (GAN)", "D) 全連接神經網路 (FCN)"], answer: "B) 卷積神經網路 (CNN)", explanation: "卷積神經網路（CNN）的設計靈感來自生物視覺皮層，其卷積層和池化層的結構特別適合捕捉圖像中的空間層次特徵。", category: "機器學習概念" },
                    { id: 17, question: "長短期記憶網路（LSTM）和門控循環單元（GRU）是為了解決哪種神經網路的梯度消失問題而提出的改進版本？", options: ["A) 卷積神經網路 (CNN)", "B) 循環神經網路 (RNN)", "C) 貝氏網路", "D) 專家系統"], answer: "B) 循環神經網路 (RNN)", explanation: "傳統的RNN在處理長序列時容易出現梯度消失或爆炸問題，導致無法學習到長期依賴關係。LSTM和GRU透過引入門控機制來有效解決這個問題。", category: "機器學習概念" },
                    { id: 18, question: "K-最近鄰演算法（KNN）是一種基於什麼原理的學習演算法？", options: ["A) 建立一個數學方程式來擬合數據", "B) 建立一個決策邊界來劃分數據", "C) 找出與新樣本最接近的K個訓練樣本來進行預測", "D) 透過獎勵與懲罰機制來學習"], answer: "C) 找出與新樣本最接近的K個訓練樣本來進行預測", explanation: "KNN是一種基於實例的學習，它不做模型的訓練，而是直接在預測時計算新樣本與所有訓練樣本的距離，並根據最近的K個鄰居來決定其類別或數值。", category: "機器學習概念" },
                    { id: 19, question: "在模型訓練中，當模型在訓練數據上表現優異，但在未見過的測試數據上表現不佳時，這種現象稱為什麼？", options: ["A) 欠擬合 (Underfitting)", "B) 過擬合 (Overfitting)", "C) 交叉驗證 (Cross-validation)", "D) 梯度下降 (Gradient Descent)"], answer: "B) 過擬合 (Overfitting)", explanation: "過擬合是指模型過度學習了訓練數據中的雜訊和細節，導致其泛化能力下降，無法很好地適應新的數據。", category: "機器學習概念" },
                    { id: 20, question: "在機器學習中，損失函數（Loss Function）的主要作用是什麼？", options: ["A) 增加模型的複雜度", "B) 衡量模型預測值與實際值之間的差異", "C) 選擇最重要的特徵", "D) 加快模型的訓練速度"], answer: "B) 衡量模型預測值與實際值之間的差異", explanation: "損失函數用來量化模型的預測誤差。模型訓練的目標就是透過調整參數來最小化損失函數的值，從而提升模型的準確性。", category: "機器學習概念" },
                    // --- 鑑別式 AI與生成式AI概念 ---
                    { id: 21, question: "鑑別式 AI（Discriminative AI）與生成式 AI（Generative AI）最主要的區別是什麼？", options: ["A) 鑑別式AI需要更多計算資源", "B) 生成式AI只能處理文字資料", "C) 鑑別式AI專注於分類或預測，而生成式AI專注於創造新內容", "D) 兩者沒有本質上的區別"], answer: "C) 鑑別式AI專注於分類或預測，而生成式AI專注於創造新內容", explanation: "這是兩者最核心的差異。鑑別式AI學習數據的決策邊界以進行判斷（例如，這是貓還是狗？），而生成式AI學習數據的潛在分佈以生成新的、相似的數據（例如，畫一隻貓）。", category: "鑑別式AI與生成式AI概念" },
                    { id: 22, question: "下列哪一個模型是典型的生成式 AI 模型？", options: ["A) 支援向量機 (SVM)", "B) 邏輯迴歸 (Logistic Regression)", "C) 決策樹 (Decision Tree)", "D) 生成對抗網路 (GAN)"], answer: "D) 生成對抗網路 (GAN)", explanation: "生成對抗網路（GAN）由一個生成器和一個判別器組成，透過相互對抗學習來生成高度逼真的新數據，是生成式AI的代表性模型。", category: "鑑別式AI與生成式AI概念" },
                    { id: 23, question: "在生成對抗網路（GAN）中，判別器（Discriminator）的角色是什麼？", options: ["A) 接收隨機雜訊並生成模擬的數據樣本", "B) 負責區分輸入的數據是真實的還是由生成器生成的", "C) 調整生成器的學習率", "D) 將高維數據壓縮到低維空間"], answer: "B) 負責區分輸入的數據是真實的還是由生成器生成的", explanation: "判別器的目標就是成為一個精明的鑒定師，盡力分辨出生成器產生的「假」數據和真實數據，它的判斷結果會反過來驅動生成器去產生更逼真的數據。", category: "鑑別式AI與生成式AI概念" },
                    { id: 24, question: "在醫療影像分析中，整合鑑別式AI和生成式AI有何優勢？", options: ["A) 只能降低模型訓練的時間", "B) 可以完全取代醫生的診斷", "C) 生成式AI可生成稀缺病理影像以增強數據，鑑別式AI則用於訓練更準確的診斷模型", "D) 只能用於生成報告，無法輔助診斷"], answer: "C) 生成式AI可生成稀缺病理影像以增強數據，鑑別式AI則用於訓練更準確的診斷模型", explanation: "這是一個典型的整合應用。由於某些疾病的醫學影像數據非常稀少，可以使用生成式AI來創建合成數據（數據增強），然後用這些增強後的數據集來訓練鑑別式AI模型，從而提高其診斷的準確性和泛化能力。", category: "鑑別式AI與生成式AI概念" },
                    { id: 25, question: "下列哪一項是鑑別式AI的典型應用？", options: ["A) 根據文字描述生成一幅畫", "B) 創作一首新的樂曲", "C) 信用風險評估（判斷用戶是否會違約）", "D) 將一張照片轉換成梵谷風格的油畫"], answer: "C) 信用風險評估（判斷用戶是否會違約）", explanation: "信用風險評估是一個典型的分類問題，需要模型根據用戶的資料判斷其屬於「會違約」或「不會違約」的類別，這是鑑別式AI的專長。", category: "鑑別式AI與生成式AI概念" },
                    { id: 26, question: "變分自編碼器（Variational Autoencoders, VAE）是一種生成模型，它主要由哪兩部分組成？", options: ["A) 生成器與判別器", "B) 卷積層與池化層", "C) 編碼器與解碼器", "D) 策略網路與價值網路"], answer: "C) 編碼器與解碼器", explanation: "VAE透過一個編碼器將輸入數據壓縮到一個低維的潛在空間，再由一個解碼器從這個潛在空間中重建出數據。這個過程讓模型學會了數據的潛在結構，從而能夠生成新的數據。", category: "鑑別式AI與生成式AI概念" },
                    { id: 27, question: "提示工程（Prompt Engineering）主要與哪一種類型的AI密切相關？", options: ["A) 鑑別式AI", "B) 生成式AI", "C) 專家系統", "D) 傳統機器學習"], answer: "B) 生成式AI", explanation: "提示工程是指設計和優化輸入提示（Prompt），以引導大型生成式AI模型（如ChatGPT）產生期望的輸出。這是與生成式AI互動的核心技巧。", category: "鑑別式AI與生成式AI概念" },
                    { id: 28, question: "擴散模型（Diffusion Models）生成數據的基本原理是什麼？", options: ["A) 透過兩個網路相互對抗學習", "B) 透過逐步從隨機雜訊中去除雜訊來重建數據", "C) 透過建立一個機率圖模型來生成數據", "D) 透過尋找數據中的決策邊界來生成數據"], answer: "B) 透過逐步從隨機雜訊中去除雜訊來重建數據", explanation: "擴散模型首先在訓練階段向真實數據中逐步添加雜訊，然後學習一個反向過程，能夠從純粹的隨機雜訊開始，一步步地將雜訊去除，最終生成一個清晰、高品質的數據樣本。", category: "鑑別式AI與生成式AI概念" },
                    { id: 29, question: "下列關於隨機森林（Random Forest）的敘述何者正確？", options: ["A) 它是一種生成式模型", "B) 它是一種非監督式學習演算法", "C) 它透過集成多棵決策樹來提高預測準確性與穩定性", "D) 它主要用於數據降維"], answer: "C) 它透過集成多棵決策樹來提高預測準確性與穩定性", explanation: "隨機森林是一種集成學習方法，它構建多個決策樹，並將它們的預測結果進行投票或平均，從而獲得比單一決策樹更好、更穩健的性能，屬於鑑別式AI的範疇。", category: "鑑別式AI與生成式AI概念" }
                ],

                init() {
                    this.loadWrongAnswers();
                },

                loadWrongAnswers() {
                    const saved = localStorage.getItem('wronglyAnsweredQuestions');
                    if (saved) {
                        this.wronglyAnsweredQuestions = JSON.parse(saved);
                    }
                },

                saveWrongAnswers() {
                    localStorage.setItem('wronglyAnsweredQuestions', JSON.stringify(this.wronglyAnsweredQuestions));
                },

                shuffleArray(array) {
                    let newArr = [...array];
                    for (let i = newArr.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [newArr[i], newArr[j]] = [newArr[j], newArr[i]];
                    }
                    return newArr;
                },

                startQuiz(mode) {
                    this.isReviewMode = mode === 'review';
                    if (this.isReviewMode) {
                        this.questions = this.shuffleArray(this.wronglyAnsweredQuestions);
                    } else {
                        this.questions = this.shuffleArray(this.fullQuestionBank).slice(0, 30);
                    }
                    this.userAnswers = Array(this.questions.length).fill(null);
                    this.questions.forEach(q => q.correctlyAnswered = null);
                    this.currentQuestionIndex = 0;
                    this.score = 0;
                    this.currentAnswerStatus = null;
                    this.quizFinished = false;
                    this.quizStarted = true;
                },

                selectAnswer(selectedIndex) {
                    if (this.currentAnswerStatus !== null) return;

                    const currentQuestion = this.questions[this.currentQuestionIndex];
                    const correctIndex = currentQuestion.options.indexOf(currentQuestion.answer);
                    
                    this.userAnswers[this.currentQuestionIndex] = selectedIndex;

                    if (selectedIndex === correctIndex) {
                        this.currentAnswerStatus = 'correct';
                        currentQuestion.correctlyAnswered = true;
                        this.score++;
                        // If in review mode and answered correctly, remove from wrong answers list
                        if (this.isReviewMode) {
                           this.wronglyAnsweredQuestions = this.wronglyAnsweredQuestions.filter(q => q.id !== currentQuestion.id);
                           this.saveWrongAnswers();
                        }
                    } else {
                        this.currentAnswerStatus = 'incorrect';
                        currentQuestion.correctlyAnswered = false;
                        // If in normal mode, add to wrong answers list (if not already there)
                        if (!this.isReviewMode) {
                            const isAlreadyWrong = this.wronglyAnsweredQuestions.some(q => q.id === currentQuestion.id);
                            if (!isAlreadyWrong) {
                                this.wronglyAnsweredQuestions.push(currentQuestion);
                                this.saveWrongAnswers();
                            }
                        }
                    }
                },

                nextQuestion() {
                    if (this.currentQuestionIndex < this.questions.length - 1) {
                        this.currentQuestionIndex++;
                        this.currentAnswerStatus = null;
                    } else {
                        this.finishQuiz();
                    }
                },

                finishQuiz() {
                    this.quizFinished = true;
                },

                restartQuiz() {
                    this.quizStarted = false;
                    this.quizFinished = false;
                },
                
                async callGeminiAPI(prompt, isStructured = false, schema = null) {
                    this.isGeminiLoading = true;
                    this.geminiResponse = '';
                    this.showGeminiModal = true;

                    const apiKey = ""; // The environment will provide the key
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                    let payload = { contents: [{ role: "user", parts: [{ text: prompt }] }] };
                    if (isStructured && schema) {
                        payload.generationConfig = { responseMimeType: "application/json", responseSchema: schema };
                    }

                    try {
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        if (!response.ok) throw new Error(`API 請求失敗，狀態碼： ${response.status}`);
                        const result = await response.json();
                        if (result.candidates && result.candidates[0]?.content?.parts[0]) {
                            const text = result.candidates[0].content.parts[0].text;
                            if (isStructured) return JSON.parse(text);
                            return text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\*(.*?)\*/g, '<em>$1</em>').replace(/```([\s\S]*?)```/g, '<pre class="bg-gray-200 p-2 rounded"><code>$1</code></pre>').replace(/\n/g, '<br>');
                        }
                        return "無法從 API 獲取有效的回應。";
                    } catch (error) {
                        console.error("呼叫 Gemini API 時發生錯誤:", error);
                        return `發生錯誤：${error.message}`;
                    } finally {
                        this.isGeminiLoading = false;
                    }
                },

                async getDeeperExplanation(index) {
                    const question = this.questions[index];
                    this.geminiModalTitle = "深入解釋 ✨";
                    const prompt = `請用更簡單、更生活化的方式，深入解釋以下這個AI概念。問題: "${question.question}" 正確答案: "${question.answer}" 原本的解析: "${question.explanation}" 請提供一個更詳細或用不同角度切入的解釋，讓初學者更容易理解這個概念的核心思想與應用。`;
                    this.geminiResponse = await this.callGeminiAPI(prompt);
                },

                async generateSimilarQuestion(index) {
                    const question = this.questions[index];
                    this.geminiModalTitle = "類似題目生成 ✨";
                    const prompt = `請根據以下主題，生成一個全新的、類似的單選題。主題/類別: "${question.category}" 請確保新題目的問題、選項、答案和解析都與原題目不同，但概念相關。請嚴格按照指定的JSON格式返回結果。`;
                    const schema = { type: "OBJECT", properties: { question: { "type": "STRING" }, options: { type: "ARRAY", items: { "type": "STRING" } }, answer: { "type": "STRING" }, explanation: { "type": "STRING" } }, required: ["question", "options", "answer", "explanation"] };
                    const newQ = await this.callGeminiAPI(prompt, true, schema);
                    if (typeof newQ === 'object' && newQ.question) {
                        this.geminiResponse = `<div class="border p-4 rounded-lg bg-gray-50"><p class="font-semibold mb-2">${newQ.question}</p><div class="space-y-2">${newQ.options.map(opt => `<div class="p-3 rounded-md text-sm bg-gray-100">${opt}</div>`).join('')}</div><div class="mt-3 p-3 bg-blue-100 border-l-4 border-blue-500 text-blue-800 rounded-r-lg"><p class="font-bold">答案：</p><p>${newQ.answer}</p><p class="font-bold mt-2">解析：</p><p>${newQ.explanation}</p></div></div>`;
                    } else {
                        this.geminiResponse = "無法生成新的題目，請稍後再試。";
                    }
                },

                async summarizeWeaknesses() {
                    let wrongAnswers = this.questions.filter(q => !q.correctlyAnswered);
                    if (wrongAnswers.length === 0) {
                        this.geminiModalTitle = "恭喜！";
                        this.geminiResponse = "您本次測驗全部答對了，沒有需要總結的弱點！";
                        this.showGeminiModal = true;
                        return;
                    }
                    this.geminiModalTitle = "弱點分析與學習建議 ✨";
                    const topics = wrongAnswers.map(q => q.category).join(', ');
                    const prompt = `我剛剛完成了一個人工智慧基礎概論的測驗，以下是我答錯題目的主題列表：${topics}。請幫我分析我的主要弱點可能在哪裡，並提供一個簡潔、條列式的學習建議，幫助我針對這些弱點進行加強。請用繁體中文回答。`;
                    this.geminiResponse = await this.callGeminiAPI(prompt);
                }
            }
        }
        // This script should be placed at the end of the body tag
        document.addEventListener('alpine:init', () => {
            Alpine.data('quizApp', quizApp);
        });
    </script>
</body>
</html>



